% !TeX root = ./documentation.tex

% Javascript und verwendete Libraries

\chapter{Technical Basics}
Im vorherigen Kapitel wurden die Grundlagen zum Davis Putman Algorithmus und des N Damen Problems genauer analysiert und definiert. Nun folgt eine Sammlung von Bibliotheken und Technologien, die für die Implementierung benötigt werden. Dabei wird vor allem auf den Einsatz dieser und der Vergleich zu eventuellen Alternativen eingegangen. 

\section{Parcel}
%Kommentar zu Koen: Sollten wir Module Bundling noch im Allgemeinen erklären oder weglassen oder ins Implementierungs Kapitel schieben?
Parcel ist ein Module Bundling Tool zur Integration von mehreren Modulen in eine Datei. Dadurch ist es möglich, multiple Module in einem einzigen Bundle an den Browser zu senden. Diese Bibliothek bietet einige sehr nützliche Funktionen an, die die Implementierung deutlich vereinfachen. Parcel nutzt Worker Prozesse, um eine multicore Compilierung zu ermöglichen und besitzt ein Filesystem Cache, um sehr schnelles Rebuilden zu ermöglichen. Dadurch ist Parcel vor allem auf Performanz im Browser ausgelegt. Um diese zusätzlich zu erhöhen, teilt Parcel die Output Bundles auf, so dass nur die benötigten Teile beim initialen Start geladen werden. Außerdem besitzt diese Bibliothek einen automatischen Support für Sprachen wie beispielsweise Javascript und CSS, wodurch keine Plugins benötigt werden. Der Programmcode und auch die Nodejs Module werden außerdem automatisch transformiert. Das ist sehr wichtig für dieses Projekt, da mit Nodejs und Pack dependencies gearbeitet wird. Ein weiteres interessantes Feature von Parcel ist das automatische Updaten der Module im Browser, wenn Änderungen durch die Entwicklung angewendet werden müssen. Das macht den Arbeitsprozess dynamisch und schneller. Das übersichtliche und verständliche Error Logging erleichtert zusätzlich dazu die Implementierung. 
%TODO Quellen einbauen (\url{https://parceljs.org/}). 
\subsection{Aktuelle Alternativen}
Parcel ist natürlich nicht das einzige Module Bundling Tool, sondern es gibt viele ähnliche Tools. Die zwei bekannten Tools Webpack und Rollup werden im folgenden Abschnitt grob angerissen und im kurzen Vergleich zu Parcel gestellt.
\paragraph{Webpack} Webpack wurde dazu erschaffen, Probleme mit dem Asset Management sinnvoll zu lösen und die Entwickler darin zu unterstützen. Dies ist auch der Grund, weshalb auch nicht-javascript Dateien eingebunden werden können. Während Parcel Out-of-the-box Support für viele Sprachen bereits mitbringt, kann Webpack durch eine Vielzahl an Plugins den Gegebenheiten angepasst und erweitert werden. Im Gegensatz zu Parcel benötigt Webpack eine config file, um die Optionen zu entry, output, plugin etc. genauer spezifieren zu können. Parcel benötigt keine und funktioniert automatisiert. Ein weiterer Unterschied ist, dass Webpack grundsätzlich eine Javascript Datei als entry point benötigt und nicht wie Parcel auch einen HTML Einstiegspunkt unterstützt. Dies kann zwar durch Drittanbieter Plugins gewährleistet werden, wird aber nicht automatisch mitgeliefert. Um einen Bundler zu erschaffen, müssen alle Formate in Javascript umgewandelt werden. Während Webpack Loaders nutzt, die im Config File definiert werden müssen, unterstützt Parcel viele Formate ohne einen zusätzlichen Aufwand des Entwicklers. Um einen Entwicklungsserver aufzubauen, der die Entwicklung und das Testen von Programmen erleichtert, muss in Webpack ein Plugin und die entsprechenden Konfigurationen hinzugefügt werden. Parcel hat einen eingebauten Entwicklungsserver, der bei jeder Änderung automatisch die Dateien neu aufbaut. Webpack unterstützt genauso wie Parcel das Hot Module Replacement. Code Splitting, um nur die benötigten Ressourcen zu Beginn zu laden und somit die Performanz im Browser zu verbessern, ist ein sehr ausgeprägtes Feature in Webpack. Dieses bietet drei Ansätze zur Umsetzung an, zwischen denen der Nutzer wählen kann. Einmal kann der Code anhand der entry Konfiguration manuell gesplittet werden, dann kann mit der Hilfe eines Plugins chunks geteilt werden und die letzte Möglichkeit ist die Aufteilung mithilfe von Inline Function Calls. Parcel unterstützt nur einen Ansatz zum Code Splitting: zero configuration code splitting. Hier wird die AUfteilung durch die dynamische import Function kontrolliert, wodurch die Module asynchron geladen werden.
\\
Trotz der großen Vielzahl der Möglichkeiten, die Webpack durch die Plugins erhält, wurde gegen dieses Tool entschieden, da deutlich mehr Zeit in die Konfiguration investiert werden müsste, währenddessen Parcel keine benötigt. Parcel beinhaltet die benötigten Features schon und ist sofort startbereit, welches den schnellen Entwicklungsprozess noch weiter antreibt. 
%TODO Koen. Eventuell hier ergänzen
\paragraph{Rollup}
%TODO Quellen einbauen https://medium.com/js-imaginea/comparing-bundlers-webpack-rollup-parcel-f8f5dc609cfd
%https://webpack.js.org/concepts
%https://rollupjs.org/guide/en

To work with Set (also Stack and Range) in JS (\url{https://immutable-js.github.io/immutable-js/}), because native Set is comparing by object by Object reference (\url{http://2ality.com/2015/01/es6-maps-sets.html#why-cant-i-configure-how-maps-and-sets-compare-keys-and-values}).

Two.js to animate and use svg files (\url{https://two.js.org/}). Maybe compare to other Libraries?

Seedrandom to replicate previous calculations (\url{https://github.com/davidbau/seedrandom})

Promises in JS (\url{https://medium.freecodecamp.org/promises-in-javascript-explained-277b98850de})

Multi Threading in JS (\url{https://medium.com/techtrument/multithreading-javascript-46156179cf9a} \& \url{https://www.html5rocks.com/de/tutorials/workers/basics/})

(Not in use yet) Combination of those two (\url{https://github.com/nolanlawson/promise-worker})