% !TeX root = ./documentation.tex

% Javascript und verwendete Libraries

\chapter{Technical Basics}
Im vorherigen Kapitel wurden die Grundlagen zum Davis Putman Algorithmus und des N Damen Problems genauer analysiert und definiert. Nun folgt eine Sammlung von Bibliotheken und Technologien, die für die Implementierung benötigt werden. Dabei wird vor allem auf den Einsatz dieser und der Vergleich zu eventuellen Alternativen eingegangen. 

\section{Parcel}
Um besser verstehen zu können, weshalb die Nutzung eines Module Bundling Tools sinnvoll für das Projekt ist, muss zuerst einmal ein allgemeines Verständnis zur Thematik des Module Bundlings geschaffen werden.
\\
Allgemein gesagt ist das Nodejs Feature Module Bundling das Zusammenfügen einer Gruppe von Modulen mit ihren Abhängigkeiten in eine einzige Datei. Der Vorteil vor allem in der Webentwicklung ist dabei, dass nicht jede einzelne Datei in dem zentralen HTML-File per Script-Tag eingefügt werden muss, sondern nur eine einzige große Datei. Die Ladezeiten der Website werden dadurch deutlich verbessert und es erhöht die Wartbarkeit während und nach dem Entwicklungsprozess. Auch die Entwicklung selbst mir objektorientierte  Programmierung wird einfacher gestaltet. Doch nun muss ein passendes Tool dafür gefunden werden. \cite{Kasireddy2016}
\\ 
\\
Parcel ist ein Module Bundling Tool zur Integration von mehreren Modulen in eine Datei. Dadurch ist es möglich, multiple Module in einem einzigen Bundle an den Browser zu senden. Diese Bibliothek bietet einige sehr nützliche Funktionen an, die die Implementierung deutlich vereinfachen. Parcel nutzt Worker Prozesse, um eine multicore Compilierung zu ermöglichen und besitzt ein Filesystem Cache, um sehr schnelles Rebuilden zu ermöglichen. Dadurch ist Parcel vor allem auf Performanz im Browser ausgelegt. Um diese zusätzlich zu erhöhen, teilt Parcel die Output Bundles auf, so dass nur die benötigten Teile beim initialen Start geladen werden. Außerdem besitzt diese Bibliothek einen automatischen Support für Sprachen wie beispielsweise Javascript und CSS, wodurch keine Plugins benötigt werden. Der Programmcode und auch die Nodejs Module werden außerdem automatisch transformiert. Das ist sehr wichtig für dieses Projekt, da mit Nodejs und Pack dependencies gearbeitet wird. Ein weiteres interessantes Feature von Parcel ist das automatische Updaten der Module im Browser, wenn Änderungen durch die Entwicklung angewendet werden müssen. Das macht den Arbeitsprozess dynamisch und schneller. Das übersichtliche und verständliche Error Logging erleichtert zusätzlich dazu die Implementierung. \cite{Govett2019}
\subsection{Aktuelle Alternativen}
Parcel ist natürlich nicht das einzige Module Bundling Tool, sondern es gibt viele ähnliche Tools. Die zwei bekannten Tools Webpack und Rollup werden im folgenden Abschnitt grob angerissen und im kurzen Vergleich zu Parcel gestellt.
\paragraph{Webpack} Webpack wurde dazu erschaffen, Probleme mit dem Asset Management sinnvoll zu lösen und die Entwickler darin zu unterstützen. Dies ist auch der Grund, weshalb auch nicht-javascript Dateien eingebunden werden können. Während Parcel Out-of-the-box Support für viele Sprachen bereits mitbringt, kann Webpack durch eine Vielzahl an Plugins den Gegebenheiten angepasst und erweitert werden. Im Gegensatz zu Parcel benötigt Webpack eine config file, um die Optionen zu entry, output, plugin etc. genauer spezifieren zu können. Parcel benötigt keine und funktioniert automatisiert. Ein weiterer Unterschied ist, dass Webpack grundsätzlich eine Javascript Datei als entry point benötigt und nicht wie Parcel auch einen HTML Einstiegspunkt unterstützt. Dies kann zwar durch Drittanbieter Plugins gewährleistet werden, wird aber nicht automatisch mitgeliefert. Um einen Bundler zu erschaffen, müssen alle Formate in Javascript umgewandelt werden. Dies wird Transformation genannt. Während Webpack Loaders nutzt, die im Config File definiert werden müssen, unterstützt Parcel viele Formate ohne einen zusätzlichen Aufwand des Entwicklers. Unter gewissen Voraussetungen kann Webpack auch die Tree Shaking Funktion unterstützen, die für die dead code Eliminierung zuständig ist. Das wäre unter anderem das Nutzen des Format  ES2015, einen "sideEffect" entry im package.json File und das Hinzufügen eines minifers, der dead code Entfernung unterstützt. Parcel unterstützt diese Funktion in keiner Weise. Um einen Entwicklungsserver aufzubauen, der die Entwicklung und das Testen von Programmen erleichtert, muss in Webpack ein Plugin und die entsprechenden Konfigurationen hinzugefügt werden. Parcel hat einen eingebauten Entwicklungsserver, der bei jeder Änderung automatisch die Dateien neu aufbaut. Webpack unterstützt genauso wie Parcel das Hot Module Replacement. Code Splitting, um nur die benötigten Ressourcen zu Beginn zu laden und somit die Performanz im Browser zu verbessern, ist ein sehr ausgeprägtes Feature in Webpack. Dieses bietet drei Ansätze zur Umsetzung an, zwischen denen der Nutzer wählen kann. Einmal kann der Code anhand der entry Konfiguration manuell gesplittet werden, dann kann mit der Hilfe eines Plugins chunks geteilt werden und die letzte Möglichkeit ist die Aufteilung mithilfe von Inline Function Calls. Parcel unterstützt nur einen Ansatz zum Code Splitting: zero configuration code splitting. Hier wird die AUfteilung durch die dynamische import Function kontrolliert, wodurch die Module asynchron geladen werden.
\\
Trotz der großen Vielzahl der Möglichkeiten, die Webpack durch die Plugins erhält, wurde gegen dieses Tool entschieden, da deutlich mehr Zeit in die Konfiguration investiert werden müsste, währenddessen Parcel keine benötigt. Parcel beinhaltet die benötigten Features schon und ist sofort startbereit, welches den schnellen Entwicklungsprozess noch weiter antreibt. Dadurch ist es einfacher und effizienter, Parcel für die Entwicklung zu nutzen, da kein großes Vorwissen benötigt wird und durch die konfigurationsarme Verwendung einfacher zu nutzen ist.

\paragraph{Rollup}Rollup ist ein Module Bundler für Javascript, welcher kleine Codesnippets in ein großes Gesamtbild zusammenfügt. Dafür wird das neue standarisierte Format ES2015 für Code Modules verwendet. Wie auch Webpack benötigt Rollup eine Config Datei, während Rollup aber auch relative Pfade und node polyfills unterstützt. Dafür muss vor der Entwicklung Zeit investiert werden, während in parcel bereits ohne Konfiguration gestartet werden kann. Um die gleiche Funktionalität von Parcel zu bieten, dass HTML auch als Entry point verwendet werden kann, muss ein Plugin für Rollup installiert werden. Während Parcel die Transformation für die Bundleerstellung automatisch durchführt, muss für Rollup ein passendes Plugin gewählt und in der config file spezifiziert werden.  Rollup unterstützt Tree Shaking ohne jegliche Voraussetzungen im Gegensatz zu Webpack. Dabei überprüft Rollup den zu importierenden Coden und exclude die aktuell nicht verwendeten Funktionen. Parcel unterstützt diese Funktion wie bereits oben genannt leider nicht. Um einen Entwicklungsserver zu nutzen, muss auch hier ein zusätzliches Plugin installiert und konfiguriert werden. Um eine Live reload Funktion zu haben, muss sogar noch ein weiteres Plugin hinzugefügt und eingerichtet werden. Es ist deutlich zeitaufwändiger als die Hands-on Unterstützung bei Parcel zu nutzen. Leider unterstützt Rollup nicht wie Parcel oder Webpack die Hot Module Replacement und verbessert somit nicht die Performanz im Browser. Im Bereich des Code Splitting gibt es bisher nur experienteller Code, der chucks in standadisierte ES module spaltet, die dann vom module loader aufgerufen werden. Dafür müssen aktuell zwei Flags in der Config File anders gesetzt werden.
\\
Auch nach diesem Vergleich ist die Entscheidung auf Parcel gefallen, da Rollup wichtige Features fehlen, die relevant für das Projekt sind und auch hier wie bei Webpack der Konfigurationsaufwand deutlich höher ist wie bei Parcel. \cite{Bhatia2018}, \cite{WebpackAuthors2019}, \cite{rollupJs-Authors2019}


\section{Immutablejs}
In der späteren Umsetzung des Davis Putman Algorithmus wird ein bekanntes Problem bei der Benutzung mit Javascript auftauchen. Es handelt sich dabei um das Vergleichen zwischen Sets. Das native Set vergleicht Objekte dabei über die Object by Object Reference. Vergleiche mit mutable Objekten ist meist sehr schwierig, da wenn ein Objekt sich ändert, sich die Lokation dieser in einer Collection auch ändert. Die Bibliothek Immutablejs ermöglicht die Erstellung von immutable Objekten, die, sobald sie erstellt wurden, nicht mehr änderbar sind. Außerdem stellt diese mehrere persistente immutable Datenstrukturen wie Stack, Set und Range für die Entwickler zur Verfügung. Damit löst diese Bibliothek das Problem der Vergleiche zwischen Objekten. \cite{Immutable.jsAuthors2019}, \cite{Rauschmayer2015}

\section{Two.js}
Diese Bibliothek ist eine zweidimensionale Zeichnungs-API, die zur Nutzung und Animation von SVG Dateien verwendet wird. Two.js unterstützt auch canvas und webgl. Der Hauptfokus von Two.js liegt deutlich auf den Vektorgrafiken, da sie stark von den motion graphics geprägt wurden. Deshalb ist die Kreation und Animation von flachen Formen verkürzt und einfacher unter der Verwendung von Two.js möglich. Two.js basiert grundlegend auf einem Scenegraph. Wenn ein Objekt gezeichnet oder erstellt wird, speichert dies die Bibliothek und merkt sich dieses. Dadurch kann nach der Erstellung jegliche Operationen auf das Objekt anwenden. Two.js beinhaltet außerdem einen Animations Loop, der sehr einfach gehalten wurde, um eine Automation oder die Kombination mit anderen Bibliotheken zu ermöglichen. Das letzte große Feature von Two.js ist der SVG Interpreter, welcher es ermöglicht, erstellte SVGs in beliebten Programmen wie Adobe Illustrator zu übernehmen und direkt in die Two.js Scene einzubringen. Dadurch wird die Möglichkeit zur Selbstgestaltung von SVGs wie Icons sehr gut unterstützt. \cite{TwoJsAuthors2019}
%TODO Koen: Vergleichbare libraries sind p5.js oder fabric.js paper.js (sehe keine nennenswerte Unterschiede für eine kurze Beschreibung)

\section{Seedrandom.js}
Diese Bibliothek von David Bau stellt einen Seeded Random Number Generator für JavaScript und kann dabei als plain Javascript, Node.js Module oder AMD module verwendet werden. Seedrandom.js wird dabei hauptsächlich dazu verwendet, um zuvor erstellte Kalkulationen durch den gleichen Seed wieder erneut zu replizieren. Dadurch können Seeds, die ein bestimmtes Problem sehr schnell lösen können oder einen für Erkärungszwecken anschaulichen Rechnungsweg bereitstellen, jederzeit für dasselbe Ergebnis wiederverwendet werden. \cite{Bau2019}

\section{Multi Threading in JS} 
Viele Programme und Applicationen, die viele Prozesse zur Abwicklung ihrer Funktionen benötigt, stehen meist vor einem Problem. Dieses Projekt beispielsweise, welches einen hohen logischen Aufwand im Hintergrund laufen hat, die Änderungen aber gleichzeitig in Echtzeit für den Nutzer sichtbar machen musst, muss mit der Schwierigkeit umgehen, dass Javascript grundsätzlich eine Single-Thread Umgebung ist und somit keine Scripte paralellisieren kann. Die Folge daraus wäre eine langsame Benutzeroberfläche und ständiges Warten auf die aktuellen Ergebnisse. Dies würde deutlich das Nutzungserlebnis verschlechtern und im schlimmsten Falle zu einer nicht nutzbaren Webseite enden.
\\
Eine Lösung zu dieser Problematik bieten sogenannte Web Worker, die von einer HTML Seite als Hintergrundprozesse abseits vom Haupt-Thread erstellt werden. Diese können dann als seperaten Thread beispielsweise rechenintensive Skripte übernehmen und somit dem Main-Thread die Verarbeitung von Nutzerinteraktionen überlassen. Die Worker kommunizieren mithilfe von Nachrichten mit dem Main-Thread und erreichen somit eine Parallelität ohne Blockinstanzen zu kreieren. \cite{Peng2017}, \cite{Bidelman2010}