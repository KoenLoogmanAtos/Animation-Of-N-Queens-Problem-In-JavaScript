% !TeX root = ./documentation.tex

\chapter{Implementation}
\label{ch:implementation}
As mentioned before in the chapter \ref{ch:tecBasics} we will be using Node.js with Parcel as a module bundler. This way we can use Node.js modules and build an HTML page that does not require a Node.js server running in the background, making it portable and executable without any prerequisites except for a browser. The implementation in JavaScript will be object orientated approach using the with ECMAScript 2015 introduced class syntax, which will make it more pleasing for the eye and less confusing.
% Class Syntax https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes

Since the Davis Putnam algorithm can have tasks with a high computational effort, we decided to use separate threads to compute and animate. So we can display all the changes to the problem as it is being solved and prevent the GUI from freezing on long lasting computations. As previously explained in chapter \ref{sec:tecWorker} this is possible with a so-called worker in JavaScript. It is important to mention here, that because the worker and main script communicate with each other via messages, we need to make sure that while computing no unwanted messages are send. Such messages could be multiple computing request being send simultaneously to the worker, because the worker will still receive messages and respond to them after finishing the all previous tasks. This could lead to problems if for example during a long lasting computation task additional computations are requested, then no other requests could be handled before all those computation tasks have been finished nor could those be interrupted. Our approach here will be to tell the main script when a computational task started and ended. This way certain UI elements can be locked while the worker computes and unlocked when the worker finished the given task.

Next we need to take a look at the mathematical part of the script. Because in JavaScript uses when comparing objects with each other their references, we will use Immutable.js as said in chapter \ref{sec:tecImmutable} to counter this problem when working with sets. Since we will have a set of clauses for the algorithm to satisfy with those clauses being sets of literals, we would need to implement a deep compare ourselves if we were to use native JavaScript. That said Immutable.js solves the set comparison, but we still need to implement literals somehow. We decided to use simple strings for the literals with the restriction of the first character not being allowed to be an ``!'', as we will use that character to indicate that the literal is negated. The choice to use strings is based on the same reason for using Immutable.js for the sets. Immutable.js has immutable structures that are compared by value, but for other objects Immutable.js compares them just like native JavaScript by their object references. This means if we were to use custom classes for literals we would need to come up with our own way of comparing them, but strings on the other hand are compared by length and character order by default. Resulting in less effort when implementing the mathematical part of the algorithm.
% Equal operator https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality_operators
% Object is https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
% Immutable is https://immutable-js.github.io/immutable-js/docs/#/is
So for example the formula $(\; p\; \lor\; \neg q\; )\; \land\; (\; s\; \lor\; r\; )$ would be implemented as the following listing \ref{code:setOfClauses} with Set being the Set class of Immutable.js and not the native one.

\begin{listing}[h!]
\begin{minted}{javascript}
let set_of_clauses = new Set(new Set('p', '!q'), new Set('s', 'r'));
// represents (p or not q) and (s or r)
\end{minted}
    \caption{Example for a set of clauses in JavaScript}
    \label{code:setOfClauses}
\end{listing}

\section{Util Object}
\label{sec:impUtil}
Because some functions like negating a literal will be used in multiple parts of the script, we will create an object to host these functions. This object will be called the Util Object. By doing so it can be imported when those functions are needed and prevent redundant code, making it easy to maintain or change.

It contains the function to negate a literal and functions for formatting clauses and literals to HTML strings. It can be expanded further in future, but for now those will do.

\section{Implementing the Algorithm of Davis \& Putnam}
\label{sec:impDavisPutnam}
The original algorithm of Davis \& Putnam is recursive and so are most of its implementations. If you were to calculate everything at one till you find a possible solution or the response that the given problem can not be satisfied, then a recursive implementation is not an issue. For our purposes, which is the visualization of the algorithm as it solves the given problem step by step, we prefer to use a iterative implementation. Because an iterative implementation can be paused at any point depending on how its implemented.

One of the challenges here is the double recursive call of the algorithm and splitting it into single unit cuts per iteration for the micro steps.

- tasks to be handled by one iteration

- needed data for those tasks (stack, clauses, literals, used, literal)

- pseudo code

\subsection{Davis Putnam Class}
\label{sub:impDavisPutnam}
This class handles the iterations of the Davis \& Putnam algorithm and stores its state.



\subsection{Davis Putnam Consumer Class}
\label{sub:impDavisPutnamConsumer}
This class is for handling the events of the Davis Putnam class. It could also be done with event listeners, but we decided to go for an class that contains the methods to be invoked on those events. These events are as follows:

- list of events

Those methods are basically placeholders, since the class is supposed to be extended by a subclass. The subclass should alter these methods to their needs.

\subsection{Davis Putnam Worker Class}
\label{sub:impDavisPutnamWorker}
This class initializes a worker for the main script to handle all the calculations. It extends the Davis Putnam Consumer from the previous chapter \ref{sub:impDavisPutnamConsumer}.

\section{Implementing N-Qeens Problem}
\label{sec:impQueens}
To be able to solve a problem with the Davis \& Putnam algorithm, one needs to be defined. Therefor we will create a function to return for a given number $n$ a set of clauses that defines a the N-Queens Problem for said $n$. The queens will be represented by a literal of the form ``row,col'' and the negated literal will mean that no queen can be placed there. Lets say for example we have $\texttt{row} := 3 \land \texttt{col} := 4$ then the literal for the queen would be as follows ``3,4'' and the negation would be ``!3,4''. This makes it easy to transform the string back into coordinates for the chessboard.

\subsection{Queens Clauses Function}
\label{sub:impQueensClauses}
This function returns a set of clauses for the N-Queens Problem.

\subsection{Chessboard Class}
\label{sub:impChessboard}
This class uses Two.js to visualize the state of the current set of clauses.

- Two.js structure

\section{Implementing User Interaction}
\label{sec:impUI}

\subsection{HTML Document}
\label{sub:impHTML}

- brief description (important ids)

\subsection{CSS Document}
\label{sub:impCSS}

- using css grid

\subsection{Frame Class}
\label{sub:impFrame}

- setup (worker and chessboard)

- event listeners